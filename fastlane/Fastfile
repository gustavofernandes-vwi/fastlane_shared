android_apk_folder = './build/app/outputs/flutter-apk'
android_aab_folder = ''

private_lane :flutter_version_values do
    version_info = flutter_version(pubspec_location: './pubspec.yaml')
    Actions.lane_context['FLUTTER_VERSION_NAME'] = version_info['version_name']
    Actions.lane_context['FLUTTER_VERSION_CODE'] = version_info['version_code']
end

desc "Exibe o código e nome de versão atual do app, conforme pubspec.yaml"
lane :version do
    UI.message Actions.lane_context['FLUTTER_VERSION_NAME']
    UI.message Actions.lane_context['FLUTTER_VERSION_CODE']
end

desc "Cria os arquivos de changelog para serem preenchidos"
desc "O conteúdo desses arquivos serão usados na hora de subir as builds"
lane :create_changelog_files do
    changelog(
        skip_create_files: false,
        skip_character_limit_check: true,
        skip_outdated_changelogs_check: true,
    )
end

private_lane :ensure_release_branch do
    version_name = Actions.lane_context['FLUTTER_VERSION_NAME']
    expected_branch = "release/#{version_name}"
    ensure_git_branch(branch: expected_branch)
end

private_lane :commit_generated_files do
    files = [
        "pubspec.lock",
        "ios/OneSignalNotificationServiceExtension/Info.plist",
        "ios/Podfile.lock",
        "macos/Flutter/GeneratedPluginRegistrant.swift",
        "lib/generated_plugin_registrant.dart",
    ]
    begin
        git_commit(
            path: files.filter {|file| File.exist?("../"+file) },
            message: "Build generated files",
            allow_nothing_to_commit: true,
        )
    rescue => exception
        UI.important(exception.message)
    end
end

private_lane :discard_git_changes do
    reset_git_repo(
        skip_clean: true,
        disregard_gitignore: false,
    )
end

private_lane :check_changelogs do |options|
    changelog(
        skip_ios: options[:skip_ios],
        skip_android: options[:skip_android],
        skip_github: options[:skip_github],
    )
end

desc "Gera as builds **Beta** para ambas as plataformas e faz upload para as ferramentas de distribuição correspondentes."
desc "Também cria a release no GitHub e gera builds executáveis (apk do android) para anexar na release."
desc "Esta é a lane de mais alto nível, que chama outras lanes para que tudo que precisa ser feito aconteça com um único comando."
desc "O tempo de execução dessa lane é altamente elevado."
lane :beta_all do |options|
    skip_ios = options[:skip_ios] || false
    skip_android = options[:skip_android] || false
    skip_github = options[:skip_github] || false

    check_changelogs(options)
    ensure_release_branch

    if !skip_android
        ensure_android_changelog_limit
    end

    if !skip_ios
        # Build for iOS and upload to AppStore Connect
        Fastlane::LaneManager.cruise_lane('ios','beta')
        commit_generated_files
    end
    
    if !skip_android
        # Build for Android and upload to Google Play Console
        Fastlane::LaneManager.cruise_lane('android','beta')
        commit_generated_files
    end
    
    if !skip_github
        # Build executables (android apk) and uploads to newly created github release
        beta_github_release
        commit_generated_files
    end
end

desc "Gera as builds de **produção** para ambas as plataformas e faz upload para as ferramentas de distribuição correspondentes."
desc "Também cria a release no GitHub e gera builds executáveis (apk do android) para anexar na release."
desc "Esta é a lane de mais alto nível, que chama outras lanes para que tudo que precisa ser feito aconteça com um único comando."
desc "O tempo de execução dessa lane é altamente elevado."
lane :prod_all do |options|
    skip_ios = options[:skip_ios] || false
    skip_android = options[:skip_android] || false
    skip_github = options[:skip_github] || false

    check_changelogs(options)
    ensure_release_branch

    if !skip_android
        ensure_android_changelog_limit
    end

    if !skip_ios
        # Build for iOS and upload to AppStore Connect
        Fastlane::LaneManager.cruise_lane('ios','prod')
        commit_generated_files
    end
    
    if !skip_android
        # Build for Android and upload to Google Play Console
        Fastlane::LaneManager.cruise_lane('android','prod')
        commit_generated_files
    end
    
    if !skip_github
        # Build executables (android apk) and uploads to newly created github release
        prod_github_release
        commit_generated_files
    end
end

desc "Gera as builds **alpha** para ambas as plataformas e faz upload para as ferramentas de distribuição correspondentes."
desc "As builds são numeradas automaticamente de acordo com o último commit e também são liberadas automaticamente"
lane :alpha_all do |options|
    skip_ios = options[:skip_ios] || false
    skip_android = options[:skip_android] || false

    ensure_git_branch(branch: 'master')

    if !skip_ios
        # Build for iOS and upload to AppStore Connect
        Fastlane::LaneManager.cruise_lane('ios','alpha')
        discard_git_changes
    end
    
    if !skip_android
        # Build for Android and upload to Google Play Console
        Fastlane::LaneManager.cruise_lane('android','alpha')
        discard_git_changes
    end

    # All builds uploaded, time to release

    if !skip_ios
        # Release iOS app on AppStore Connect
        Fastlane::LaneManager.cruise_lane('ios','release_alpha')
    end

    if !skip_android
        # Release Android app on Google Play Console
        Fastlane::LaneManager.cruise_lane('android','release_alpha')
    end
end

desc "Cria a release no GitHub e gera builds executáveis (apk do android) para anexar na release."
lane :beta_github_release do
    Fastlane::LaneManager.cruise_lane('android','beta_for_github')

    version_name = Actions.lane_context['FLUTTER_VERSION_NAME']
    version_code = Actions.lane_context['FLUTTER_VERSION_CODE']
    add_git_tag(
        includes_lane: false,
        prefix: "v",
        build_number: version_name,
        postfix: "-beta.#{version_code}"
    )
    push_git_tags

    set_github_release(
        name: "Release #{version_name} - beta (build #{version_code})",
        repository_name: ENV['REPOSITORY_NAME'],
        api_token: ENV['GITHUB_TOKEN'],
        is_draft: true,
        is_prerelease: true,
        upload_assets: Actions.lane_context['GITHUB_RELEASE_ASSETS'],
        commitish: "release/#{version_name}",
        tag_name: last_git_tag,
        description: (File.read(Actions.lane_context['CHANGELOG_GITHUB_FILE'].sub! './fastlane/', '') rescue "_No changelog provided_"),
    )
end

desc "Cria a release no GitHub e gera builds executáveis (apk do android) para anexar na release."
lane :prod_github_release do
    Fastlane::LaneManager.cruise_lane('android','prod_for_github')

    version_name = Actions.lane_context['FLUTTER_VERSION_NAME']
    version_code = Actions.lane_context['FLUTTER_VERSION_CODE']
    add_git_tag(
        includes_lane: false,
        prefix: "v",
        build_number: version_name,
    )
    push_git_tags

    set_github_release(
        name: "Release #{version_name}",
        repository_name: ENV['REPOSITORY_NAME'],
        api_token: ENV['GITHUB_TOKEN'],
        is_draft: true,
        upload_assets: Actions.lane_context['GITHUB_RELEASE_ASSETS'],
        commitish: "release/#{version_name}",
        tag_name: last_git_tag,
        description: (File.read(Actions.lane_context['CHANGELOG_GITHUB_FILE'].sub! './fastlane/', '') rescue "_No changelog provided_"),
    )
end

platform :ios do

    desc "Gera a build **beta** do iOS e faz upload para o AppStore Connect (TestFlight)"
    lane :beta do
        ensure_release_branch
        flutter_build(build_args: ["--flavor=beta"])
        gym(
            workspace: 'ios/Runner.xcworkspace',
            scheme: 'beta',
            clean: true,
            export_method: "app-store",
            export_xcargs: "-allowProvisioningUpdates",
        )
        pilot(
            # skip_submission: true,
            skip_waiting_for_build_processing: true,
            username: ENV['APPSTORE_CONNECT_USERNAME'],
            changelog: (File.read(Actions.lane_context['CHANGELOG_IOS_FILE'].sub! './fastlane/', '') rescue ""),
        )
    end

    desc "Gera a build de **produção** do iOS e faz upload para o AppStore Connect (TestFlight)"
    lane :prod do
        ensure_release_branch
        flutter_build(build_args: ["--flavor=prod"])
        gym(
            workspace: 'ios/Runner.xcworkspace',
            scheme: 'prod',
            clean: true,
            export_method: "app-store",
            export_xcargs: "-allowProvisioningUpdates",
        )
        pilot(
            # skip_submission: true,
            skip_waiting_for_build_processing: true,
            username: ENV['APPSTORE_CONNECT_USERNAME'],
            changelog: (File.read(Actions.lane_context['CHANGELOG_IOS_FILE'].sub! './fastlane/', '') rescue ""),
        )
    end

    lane :alpha do
        ensure_git_branch(branch: 'master')

        date = lastCommitDateTIme
        version_name = '0.0.1'
        version_code = dateTimeToUtcTimestamp(date)

        flutter_build(
            build_args: ["--flavor=alpha"],
            build_number: version_code,
            build_name: version_name,
        )
        gym(
            workspace: 'ios/Runner.xcworkspace',
            scheme: 'alpha',
            clean: true,
            export_method: "app-store",
            export_xcargs: "-allowProvisioningUpdates",
        )
        pilot(
            username: ENV['APPSTORE_CONNECT_USERNAME'],
            app_version: version_name,
            build_number: "#{version_code}",
            changelog: 'Sem informações sobre essa versão no momento',
        )
    end

    lane :release_alpha do
        pilot(
            username: ENV['APPSTORE_CONNECT_USERNAME'],
            distribute_external: true,
            app_version: version_name,
            build_number: "#{version_code}",
            groups: ['Devs'],
        )
    end
end

platform :android do

    desc "Gera o appbundle do **beta** para Android e faz upload para o Google Play Console"
    lane :beta do
        ensure_android_changelog_limit
        ensure_release_branch
        begin
            flutter_build(build: 'appbundle')
        rescue => exception
            raise exception unless exception.message.include?('Gradle build failed to produce an .aab file. It\'s likely that this file was generated under')
            UI.important(exception.message)
        end
        version_name = Actions.lane_context['FLUTTER_VERSION_NAME']
        version_code = Actions.lane_context['FLUTTER_VERSION_CODE']
        supply(
            track: 'internal',
            aab: './build/app/outputs/bundle/betaRelease/app-beta-release.aab',
            release_status: 'draft',
            version_name: "#{version_code} (#{version_name})",
            rollout: 1,
        )
    end

    desc "Gera o appbundle da **produção** para Android"
    lane :prod do
        ensure_android_changelog_limit
        ensure_release_branch
        begin
            flutter_build(build: 'appbundle')
        rescue => exception
            raise exception unless exception.message.include?('Gradle build failed to produce an .aab file. It\'s likely that this file was generated under')
            UI.important(exception.message)
        end
        version_name = Actions.lane_context['FLUTTER_VERSION_NAME']
        version_code = Actions.lane_context['FLUTTER_VERSION_CODE']
        supply(
            aab: './build/app/outputs/bundle/prodRelease/app-prod-release.aab',
            release_status: 'draft',
            version_name: "#{version_code} (#{version_name})",
            rollout: 1,
        )
    end

    lane :alpha do
        ensure_android_changelog_limit
        ensure_git_branch(branch: 'master')

        date = lastCommitDateTIme
        version_name = '0.0.1'
        version_code = dateTimeToUtcTimestamp(date)
        begin
            flutter_build(
                build: 'appbundle',
                build_number: version_code,
                build_name: version_name,
            )
        rescue => exception
            raise exception unless exception.message.include?('Gradle build failed to produce an .aab file. It\'s likely that this file was generated under')
            UI.important(exception.message)
        end


        File.open("./metadata/android/pt-BR/changelogs/#{version_code}.txt", "w") {}
        File.write(
            "./metadata/android/pt-BR/changelogs/#{version_code}.txt",
            'Sem informações sobre essa versão no momento',
        )

        supply(
            track: 'internal',
            aab: './build/app/outputs/bundle/alphaRelease/app-alpha-release.aab',
            release_status: 'draft',
            version_name: "#{version_code} (#{version_name})",
            rollout: 1,
        )

        File.delete("./metadata/android/pt-BR/changelogs/#{version_code}.txt")
    end

    lane :release_alpha do
        supply(
            skip_upload_aab: true,
            track: 'internal',
            release_status: 'completed',
            version_name: "#{version_code} (#{version_name})",
            rollout: 1,
        )
    end

    lane :beta_for_github do
        ensure_release_branch
        begin
            flutter_build(build: 'apk')
        rescue => exception
            raise exception unless exception.message.include?('Gradle build failed to produce an .apk file. It\'s likely that this file was generated under')
            UI.important(exception.message)
        end
        Actions.lane_context['GITHUB_RELEASE_ASSETS'] << "#{android_apk_folder}/app-beta-release.apk"
    end

    lane :prod_for_github do
        ensure_release_branch
        begin
            flutter_build(build: 'apk')
        rescue => exception
            raise exception unless exception.message.include?('Gradle build failed to produce an .apk file. It\'s likely that this file was generated under')
            UI.important(exception.message)
        end
        Actions.lane_context['GITHUB_RELEASE_ASSETS'] << "#{android_apk_folder}/app-prod-release.apk"
    end
end

def dateTimeToUtcTimestamp(date)
    signal = date.strftime("%z")[0, 1]
    hours_offset = date.strftime("%z")[1, 2].to_i
    timestamp_offset = hours_offset * 60 * 60
    case signal
    when "-"
        return date.to_time.to_i + timestamp_offset
    when "+"
        return date.to_time.to_i - timestamp_offset
    end
end

def lastCommitDateTIme
    git_log = `git log -n1 --pretty="%ci"`
    git_log = git_log.strip
    return DateTime.strptime(git_log, "%Y-%m-%d %H:%M:%S %z")
end